import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "MenuProps", "LabelProps", "InputProps", "error", "label", "hint", "value", "noOptionsText", "focusOnOpen", "onChange", "onOpen", "onClose", "getOptionDisabled", "getOptionValue", "getOptionLabel", "multiple", "size", "disabled", "scroll", "readOnly", "options", "placeholder", "fullWidth", "sortAlphabetically", "submitOnBlur", "maxMenuHeight", "showClearIcon", "renderLabelIconEnd", "renderOptionLabel", "renderSearchEmptyMenuItem", "renderGroup", "groupBy"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import PT from 'prop-types';
import Tick from '@scaleflex/icons/tick';
import { intrinsicComponent, objectValues } from '../../utils/functions';
import { propTypes as labelPropTypes } from '../label/label.component';
import { propTypes as inputPropTypes } from '../input/input.component';
import ArrowTick from '../arrow-tick';
import Input from '../input';
import Tag from '../tag';
import MenuItem, { MenuItemActions } from '../menu-item';
import { InputSize } from '../../utils/types';
import { Size } from '../menu-item/types';
import Styled from './autocomplete.styles';
import { renderLabel, renderHint, defaultGetOptionValue, defaultGetOptionLabel } from './autocomplete.utils';
import { useAutocomplete } from './autocomplete.hook';
var Autocomplete = intrinsicComponent(function (props, ref) {
  var children = props.children,
    MenuProps = props.MenuProps,
    LabelPropsData = props.LabelProps,
    InputPropsData = props.InputProps,
    error = props.error,
    label = props.label,
    hint = props.hint,
    value = props.value,
    noOptionsText = props.noOptionsText,
    focusOnOpen = props.focusOnOpen,
    onChange = props.onChange,
    onOpen = props.onOpen,
    onClose = props.onClose,
    _props$getOptionDisab = props.getOptionDisabled,
    getOptionDisabled = _props$getOptionDisab === void 0 ? function () {
      return false;
    } : _props$getOptionDisab,
    _props$getOptionValue = props.getOptionValue,
    getOptionValue = _props$getOptionValue === void 0 ? defaultGetOptionValue : _props$getOptionValue,
    _props$getOptionLabel = props.getOptionLabel,
    getOptionLabel = _props$getOptionLabel === void 0 ? defaultGetOptionLabel : _props$getOptionLabel,
    multiple = props.multiple,
    size = props.size,
    disabled = props.disabled,
    scroll = props.scroll,
    readOnly = props.readOnly,
    options = props.options,
    placeholder = props.placeholder,
    fullWidth = props.fullWidth,
    sortAlphabetically = props.sortAlphabetically,
    submitOnBlur = props.submitOnBlur,
    _props$maxMenuHeight = props.maxMenuHeight,
    maxMenuHeight = _props$maxMenuHeight === void 0 ? 250 : _props$maxMenuHeight,
    _props$showClearIcon = props.showClearIcon,
    showClearIcon = _props$showClearIcon === void 0 ? false : _props$showClearIcon,
    renderLabelIconEnd = props.renderLabelIconEnd,
    renderOptionLabel = props.renderOptionLabel,
    renderSearchEmptyMenuItem = props.renderSearchEmptyMenuItem,
    renderGroup = props.renderGroup,
    groupBy = props.groupBy,
    rest = _objectWithoutProperties(props, _excluded);
  var _useAutocomplete = useAutocomplete(_objectSpread(_objectSpread({}, props), {}, {
      getOptionValue: getOptionValue,
      getOptionLabel: getOptionLabel,
      getOptionDisabled: getOptionDisabled
    })),
    formattedValue = _useAutocomplete.formattedValue,
    filteredOptions = _useAutocomplete.filteredOptions,
    groupedFilteredOptions = _useAutocomplete.groupedFilteredOptions,
    optionsList = _useAutocomplete.optionsList,
    inputRef = _useAutocomplete.inputRef,
    inputValue = _useAutocomplete.inputValue,
    isValueSelected = _useAutocomplete.isValueSelected,
    open = _useAutocomplete.open,
    anchorEl = _useAutocomplete.anchorEl,
    handleMenuItemClick = _useAutocomplete.handleMenuItemClick,
    handleOpenMenuClick = _useAutocomplete.handleOpenMenuClick,
    handleChangeSearchTerm = _useAutocomplete.handleChangeSearchTerm,
    handleCloseMenuClick = _useAutocomplete.handleCloseMenuClick,
    handleOnRemoveItem = _useAutocomplete.handleOnRemoveItem,
    handleOnBlur = _useAutocomplete.handleOnBlur,
    handleKeyDown = _useAutocomplete.handleKeyDown,
    handleClearIconClick = _useAutocomplete.handleClearIconClick,
    checkIsIdSelected = _useAutocomplete.checkIsIdSelected,
    getOptionById = _useAutocomplete.getOptionById;
  var isMultiple = Boolean(multiple) && Array.isArray(formattedValue);
  var renderMenuItem = function renderMenuItem(option) {
    var optionId = getOptionValue(option);
    var optionLabel = getOptionLabel(option);
    var isActive = checkIsIdSelected(optionId);
    return /*#__PURE__*/React.createElement(MenuItem, {
      key: optionId,
      value: optionId,
      size: size,
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      },
      disabled: getOptionDisabled(option),
      active: isActive,
      onClick: handleMenuItemClick(option),
      enableScrollIntoView: true
    }, renderOptionLabel ? renderOptionLabel(option) : optionLabel, isActive && !renderOptionLabel && /*#__PURE__*/React.createElement(MenuItemActions, null, /*#__PURE__*/React.createElement(Styled.TickIcon, null, /*#__PURE__*/React.createElement(Tick, {
      size: 12
    }))));
  };
  var renderTags = function renderTags() {
    return isMultiple && formattedValue.map(function (optionId, index) {
      var option = getOptionById(optionId);
      var optionLabel = option ? getOptionLabel(option) : optionId;
      return /*#__PURE__*/React.createElement(Tag, {
        key: optionId,
        tagIndex: index,
        crossIcon: true,
        onRemove: function onRemove(_, event) {
          return handleOnRemoveItem(event, optionId);
        },
        title: optionLabel,
        size: size
      }, optionLabel);
    });
  };
  var renderMenuContent = function renderMenuContent() {
    if (filteredOptions.length > 0) {
      if (groupBy) {
        return groupedFilteredOptions.map(function (_ref, index) {
          var groupOptions = _ref.options,
            groupedByValue = _ref.groupedByValue;
          var groupKey = ['string', 'number'].includes(_typeof(groupedByValue)) ? groupedByValue : index;
          var groupChildren = groupOptions.map(renderMenuItem);
          return renderGroup ? renderGroup({
            key: groupKey,
            group: groupedByValue,
            children: groupChildren
          }) : /*#__PURE__*/React.createElement(Styled.OptionGroup, {
            key: groupKey
          }, groupChildren);
        });
      }
      return filteredOptions.map(renderMenuItem);
    }
    if (optionsList.length > 0 && renderSearchEmptyMenuItem) {
      return renderSearchEmptyMenuItem();
    }
    return /*#__PURE__*/React.createElement(MenuItem, {
      noOptionsText: true,
      size: size
    }, noOptionsText);
  };
  return /*#__PURE__*/React.createElement(Styled.Autocomplete, _extends({
    ref: ref
  }, rest), renderLabel({
    label: label,
    error: error,
    size: size,
    LabelProps: LabelPropsData
  }), /*#__PURE__*/React.createElement(Styled.AutocompleteContainer, {
    onClick: disabled || readOnly ? undefined : handleOpenMenuClick
  }, /*#__PURE__*/React.createElement(Input, _extends({}, isMultiple ? {
    renderTags: renderTags,
    selectedItems: formattedValue
  } : {}, InputPropsData || {}, {
    ref: inputRef,
    size: size,
    value: inputValue,
    readOnly: readOnly,
    error: error,
    focusOnMount: focusOnOpen,
    onKeyDown: handleKeyDown,
    onChange: handleChangeSearchTerm,
    onBlur: handleOnBlur,
    disabled: disabled,
    placeholder: placeholder,
    fullWidth: fullWidth,
    isEllipsis: true,
    iconEnd: function iconEnd() {
      return /*#__PURE__*/React.createElement(Styled.InputIconEndContainer, null, renderLabelIconEnd && renderLabelIconEnd({
        isMultiple: isMultiple,
        option: !isMultiple && formattedValue && typeof formattedValue === 'string' ? getOptionById(formattedValue) : null
      }), /*#__PURE__*/React.createElement(ArrowTick, _extends({}, !disabled && !readOnly ? {
        onClick: handleOpenMenuClick
      } : {}, {
        type: open ? 'top' : 'bottom',
        IconProps: {
          size: size === Size.Md ? 11 : 10
        }
      })));
    }
  }, showClearIcon ? {
    clearIcon: isValueSelected && /*#__PURE__*/React.createElement(Styled.CrossIcon, {
      size: size === 'md' ? 11 : 10
    }),
    clearIconClick: handleClearIconClick
  } : {}))), /*#__PURE__*/React.createElement(Styled.Menu, _extends({
    onClose: handleCloseMenuClick,
    open: open,
    scroll: scroll,
    anchorEl: anchorEl,
    maxMenuHeight: maxMenuHeight
  }, MenuProps), renderMenuContent()), renderHint({
    hint: hint,
    error: error,
    size: size
  }));
});
Autocomplete.defaultProps = {
  size: InputSize.Md,
  multiple: false,
  disabled: false,
  scroll: true,
  readOnly: false,
  sortAlphabetically: false,
  options: [],
  noOptionsText: 'No options'
};
Autocomplete.propTypes = {
  children: PT.oneOfType([PT.element, PT.arrayOf(PT.element)]),
  size: PT.oneOf(objectValues(InputSize)),
  LabelProps: PT.exact(labelPropTypes),
  InputProps: PT.exact(inputPropTypes),
  value: PT.oneOfType([PT.string, PT.array]),
  label: PT.node,
  hint: PT.node,
  options: PT.array.isRequired,
  noOptionsText: PT.string,
  placeholder: PT.string,
  readOnly: PT.bool,
  fullWidth: PT.bool,
  multiple: PT.bool,
  disabled: PT.bool,
  scroll: PT.bool,
  focusOnOpen: PT.bool,
  error: PT.bool,
  onChange: PT.func,
  onOpen: PT.func,
  onClose: PT.func,
  getOptionDisabled: PT.func,
  getOptionValue: PT.func,
  getOptionLabel: PT.func,
  submitOnBlur: PT.func,
  sortAlphabetically: PT.bool,
  showClearIcon: PT.bool,
  maxMenuHeight: PT.oneOfType([PT.string, PT.number]),
  renderLabelIconEnd: PT.func,
  renderOptionLabel: PT.func,
  renderSearchEmptyMenuItem: PT.func,
  groupBy: PT.func
};
export default Autocomplete;