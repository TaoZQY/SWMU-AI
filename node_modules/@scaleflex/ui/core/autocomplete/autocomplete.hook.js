import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useRef, useState, useMemo, useCallback, useEffect } from 'react';
import { useDebounce } from '@scaleflex/ui/hooks/use-debounce';
import { escapeRegExp } from '../../utils/functions';
export function useAutocomplete(props) {
  var value = props.value,
    multiple = props.multiple,
    options = props.options,
    sortAlphabetically = props.sortAlphabetically,
    getOptionLabel = props.getOptionLabel,
    getOptionValue = props.getOptionValue,
    onOpen = props.onOpen,
    onChange = props.onChange,
    onClose = props.onClose,
    submitOnBlur = props.submitOnBlur,
    getOptionDisabled = props.getOptionDisabled,
    groupBy = props.groupBy;
  var _useState = useState(undefined),
    _useState2 = _slicedToArray(_useState, 2),
    anchorEl = _useState2[0],
    setAnchorEl = _useState2[1];
  var _useState3 = useState(''),
    _useState4 = _slicedToArray(_useState3, 2),
    searchTerm = _useState4[0],
    setSearchTerm = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isSearchMode = _useState6[0],
    setIsSearchMode = _useState6[1];
  var inputRef = useRef(null);
  var open = Boolean(anchorEl);
  var debouncedSearchTerm = useDebounce(searchTerm, 300);
  useEffect(function () {
    if (!isSearchMode) {
      setSearchTerm('');
    }
  }, [isSearchMode]);
  var formattedValue = useMemo(function () {
    if (multiple) {
      return _toConsumableArray(new Set(Array.isArray(value) ? value : [])); // Format + remove duplications
    }
    return (Array.isArray(value) ? '' : value) || '';
  }, [multiple, value]);
  var isMultiple = Boolean(multiple) && Array.isArray(formattedValue);
  var isValueSelected = isMultiple ? formattedValue.length > 0 : Boolean(formattedValue);
  var optionsList = useMemo(function () {
    var nextFilteredOptions = _toConsumableArray(options || []);
    if (sortAlphabetically) {
      return nextFilteredOptions.sort(function (a, b) {
        return getOptionLabel(a).localeCompare(getOptionLabel(b));
      });
    }
    return nextFilteredOptions;
  }, [options, sortAlphabetically]);
  var getOptionById = useCallback(function (optionId) {
    return optionsList.find(function (option) {
      return getOptionValue(option) === optionId;
    });
  }, [optionsList]);
  var inputValue = useMemo(function () {
    // When there is searchTerm we should show it in Input
    if (isSearchMode) {
      return searchTerm;
    }
    // If value is array it's shown tags in Input area, hance no need to return anything here so we send empty string
    if (Array.isArray(formattedValue)) {
      return '';
    }
    var selectedOption = getOptionById(formattedValue);
    return selectedOption ? getOptionLabel(selectedOption) : '';
  }, [searchTerm, optionsList, formattedValue, isSearchMode]);
  var checkIsIdSelected = useCallback(function (optionId) {
    return isMultiple ? formattedValue.includes(optionId) : formattedValue === optionId;
  }, [isMultiple, formattedValue]);
  var filteredOptions = useMemo(function () {
    return debouncedSearchTerm ? optionsList.filter(function (option) {
      return new RegExp(escapeRegExp(debouncedSearchTerm), 'i').test(getOptionLabel(option));
    }) : optionsList;
  }, [optionsList, debouncedSearchTerm]);
  var groupedFilteredOptions = useMemo(function () {
    if (groupBy) {
      var groupedMap = filteredOptions.reduce(function (accumMap, option) {
        var _accumMap$get;
        var key = groupBy(option);
        if (!accumMap.has(key)) {
          accumMap.set(key, {
            options: [],
            groupedByValue: key
          });
        }
        (_accumMap$get = accumMap.get(key)) === null || _accumMap$get === void 0 || (_accumMap$get = _accumMap$get.options) === null || _accumMap$get === void 0 || _accumMap$get.push(option);
        return accumMap;
      }, new Map());
      return _toConsumableArray(groupedMap).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          _ = _ref2[0],
          group = _ref2[1];
        return group;
      });
    }
    return [{
      options: filteredOptions
    }];
  }, [filteredOptions, groupBy]);
  var handleOpenMenuClick = function handleOpenMenuClick(event) {
    setAnchorEl(inputRef.current);
    if (onOpen) {
      onOpen(event);
    }
  };
  var handleCloseMenuClick = function handleCloseMenuClick(event) {
    setAnchorEl(undefined);
    setIsSearchMode(false);
    if (onClose) {
      onClose(event);
    }
  };
  var handleMenuItemClick = function handleMenuItemClick(option) {
    return function () {
      if (typeof onChange === 'function' && !getOptionDisabled(option)) {
        var id = getOptionValue(option);
        var newValue = id;
        if (isMultiple) {
          var newValueSet = new Set(formattedValue);
          newValueSet[newValueSet.has(id) ? 'delete' : 'add'](id);
          newValue = _toConsumableArray(newValueSet);
        }
        onChange(newValue);
        if (!isMultiple) {
          handleCloseMenuClick();
        } else {
          setIsSearchMode(false);
        }
      }
    };
  };
  var handleChangeSearchTerm = function handleChangeSearchTerm(event) {
    setSearchTerm(event.currentTarget.value);
    setAnchorEl(inputRef.current);
    setIsSearchMode(true);
  };
  var handleOnBlur = function handleOnBlur() {
    if (submitOnBlur) {
      submitOnBlur();
    }
    setIsSearchMode(false);
    setAnchorEl(undefined);
  };
  var handleOnRemoveItem = function handleOnRemoveItem(event, optionId) {
    event.stopPropagation();
    if (isMultiple && onChange) {
      var newValueSet = new Set(formattedValue);
      newValueSet[newValueSet.has(optionId) ? 'delete' : 'add'](optionId);
      onChange(_toConsumableArray(newValueSet));
    }
    handleOnBlur();
  };
  var handleKeyDown = function handleKeyDown(event) {
    if (open) {
      // TODO: Check do we need this
      // if (event.key === 'ArrowUp') {
      //   if (currentItemIndex > 0) {
      //     getNextAvailableOption(currentItemIndex - 1, event.key);
      //   } else {
      //     getNextAvailableOption(filteredOptions.length - 1, event.key);
      //   }
      // }

      // if (event.key === 'ArrowDown') {
      //   if (currentItemIndex < filteredOptions.length - 1) {
      //     getNextAvailableOption(currentItemIndex + 1, event.key);
      //   } else {
      //     getNextAvailableOption(0, event.key);
      //   }
      // }

      // if (event.key === 'Enter' && currentItemIndex >= 0) {
      //   const selectedOption = filteredOptions[currentItemIndex];

      //   if (typeof selectedOption === 'string') {
      //     handleSelectedItem(event, selectedOption, -1, getOptionIndex(selectedOption));
      //   } else {
      //     handleSelectedItem(
      //       event,
      //       getOptionLabel(selectedOption),
      //       getOptionValue(selectedOption),
      //       getOptionIndex(getOptionLabel(selectedOption))
      //     );
      //   }
      // }

      if (event.key === 'Escape') {
        handleCloseMenuClick(event);
      }
    }
  };
  var handleClearIconClick = function handleClearIconClick() {
    if (onChange) {
      onChange(isMultiple ? [] : '');
    }
  };
  return {
    formattedValue: formattedValue,
    filteredOptions: filteredOptions,
    groupedFilteredOptions: groupedFilteredOptions,
    optionsList: optionsList,
    inputRef: inputRef,
    inputValue: inputValue,
    isValueSelected: isValueSelected,
    open: open,
    anchorEl: anchorEl,
    handleMenuItemClick: handleMenuItemClick,
    handleOpenMenuClick: handleOpenMenuClick,
    handleChangeSearchTerm: handleChangeSearchTerm,
    handleCloseMenuClick: handleCloseMenuClick,
    checkIsIdSelected: checkIsIdSelected,
    getOptionById: getOptionById,
    handleOnRemoveItem: handleOnRemoveItem,
    handleOnBlur: handleOnBlur,
    handleKeyDown: handleKeyDown,
    handleClearIconClick: handleClearIconClick
  };
}